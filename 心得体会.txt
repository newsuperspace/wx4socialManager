一、Junit测试并不需要通过Maven编译，MAVEN编译是用来将src目录中各个源码文件编译成字节码文件后放入到临时的target文件中
然后在整个工程部署到web应用服务器的时候，在从target、WEB-INF、webroot、Maven Dependencies等文件夹中将文件拷贝服务器的web应用目录中去。
而Junit测试仅仅是本地编译，因此无需Maven编译的参与。

二、通常JUnit测试都只能测试Service层到DAO层，如果要测试Action就必须有WEB应用服务器的参与。
因此如果Action有类文件异常，并不影响Service层到Dao层再到数据库这一链条的Junit测试

三、即便工程中有的类存在错误，也可以通过Maven编译，并部署到WEB应用服务器，这是因为
Maven编译只是负责编译源码文件，至于文件中有没有错误它不管，而部署到服务器只要能通过S2SH这三个框架一系列的初始化过程，在这一过程中
不会涉及到有错误的类中的错误点而抛出异常就可以成功部署到服务器。

因此对于工程改造，只要有错误的类无关S2SH框架在部署到web应用服务器时候的初始化过程，那么你完全可以一点儿一点儿修改，不需要所有类错误都消除
后才能部署到服务器

四、带着错误的web应用，只要在部署到web应用服务器时S2SH框架的初始化过程不涉及到你有错误的类的方法，就能成功将带错误的web应用部署到web应用服务器，
接下来你在使用该带错误的web应用的时候，只要请求过程（ACTION → SERVICE → DAO ）中不涉及到你有错误的类的方法，该web应用程序也能正确响应你的请求。
因此我们完全可以在实际web应用部署环境中一点一点修改应用中的错误，只要S2SH三维框架工作正常（能顺利将你有错误的web应用部署到web应用服务器就表示S2SH框架工作正常）就完全没问题  ★★★★★

五、有关include动态和静态包含
可以参考https://blog.csdn.net/fn_2015/article/details/70311495
但我实际测试发现：
1、动态包含的缺陷是如果页面上（不管是主页面和从页面）只要不含有头部信息且文档中有存在汉字就会出现乱码，这样导致原本希望通过静态包含将文档头部写在被包含JSP中的计划落空，因为主页面中在编译时缺少头部信息则导致页面中出现乱码，解决方法就是不得不手写全文档头部信息。
2、动态包含并不止是将被包含文档中的<body>中的内容复制粘贴到主页面，而是将被包含文档中的所有内容复制粘贴到<jsp:include>标签处，而考虑到第一点所说的乱码问题不得不在每个JSP文档中写全头部信息，这就导致主文档中出现大量重复的头部信息，解决办法我想是精简“非主页文档”中的头部信息，只保留有关纠正乱码的部分，之后可以尝试一下。
六、对JSP文档的修改是实时生效的，不用再经过Maven Compile → 重新部署到TOMCAT这样的过程，只要刷新浏览器就能看到改变，对调试提供了很大便利。但是由于JSP本质就是Servlet，而Servlet就是类，那么按道理普通类也应该可以直接看到变化？但实际发现对普通类的修改必须通过Maven编译和重新部署到TOMCAT才能看到变化，我猜测可能是JSP保存后会自动编译成servlet类，而存储位置与基于Maven的普通类的字节码文件位置不同，因此普通类享受不到JSP及时生效的便捷。

至此，虽然WEB应用中的类带有错误方法，但只要这些方法不影响到WEB应用被部署到TOMCAT中时S2SH的初始化，那么即便WEB应用有错误也能顺利通过Maven的compile并且成功部署到TOMCAT，且不影响没有错误的部分响应浏览器请求，因此我可以按部就班分模块的写出与前台呼应的后台代码，这样当所有功能完成时，也就是整个WEB应用没有错误的完美之时。