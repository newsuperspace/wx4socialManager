// ---------------------------Shiro认证操作者身份---------------------------
		Subject subject = SecurityUtils.getSubject();
		String principal = (String) subject.getPrincipal();
		// 执行当前新建操作的管理者的User对象
		User doingMan = null;
		// 标记当前执行者是否是admin
		boolean isAdmin = false;
		if (28 == principal.length()) {
			// openID是恒定不变的28个字符，说明本次登陆是通过openID登陆的（微信端自动登陆/login.jsp登陆）
			doingMan = this.queryByOpenId(principal);
		} else {
			// 用户名登陆（通过signin.jsp页面的表单提交的登陆）
			// 先判断是不是使用admin+admin 的方式登录的测试管理员
			if ("admin".equals(principal)) {
				isAdmin = true;
			} else {
				// 非admin用户登录
				doingMan = this.getUserByUsername(principal);
			}
		}



总计划：
1、完成MinusFirstLevel展示详情Modal的功能
2、层级对象创建的时候生成具有特定格式的二维码，初步设计结构是
"level_-1$id_c7ca3c4c-c084-41bc-babb-33c60f28fc30"
这样当用户通过微信扫描某个层级对象的二维码的时候，该字符串就会从微信服务器传递到我们自己的服务器，然后通过分析就能得知该用户扫描要加入的组织层级对象的级别，并通过id获取到该层级对象，完成一系列修改用户所在层级位置的操作。


13、实名认证页面
14、修改微信公众号菜单，取消实名认证这个菜单组，使得所有新加入用户直接就能看到正式用户菜单，但是在我们自己的web应用后台做一个Filter或Interceptor操作检测访问系统功能的用户是否完成实名认证（cardid是否为null）如果没有则跳转到实名认证JSP页面，强制要求用户实名认证，否则不能使用任何功能，这就解决了微信菜单缓存的问题。
15、重新搭建微信端对我应用程序页面的OATHUR2.0 、 API等的设置
16、重新开启websocket，实现扫描二维码登录web后台操作。




细节计划：



Bug修正：

5、人员派任界面————当前操作者层级对象，且次级为null的人员均在此目录中显示，具有如下功能：
（5）下层级人员包括直属层级+所有子孙层级的人员；
	直属人员是属于自己当前层级，但不属于任何子层级的人员；
	当前层级只有权操作直属人员，包括更改tag、委任、解除委任、分派给次层级；
	当前层级无权更改非直属人员，也就是说不能跨级操作人员的tag、委任、分派等；
	这遵循了“不在其位，不谋其政”的管理原则。
	


但是新发现一个bug，在操作有关userDao的时候，会逐步加长user表中qrcode字段的长度，从而到处 too long的SQL异常，接下来我要弄明白为什么会出现这种情况
//weixin//weixin//weixin//weixin/qrcode/4/9/ba9c4b18-57eb-46ea-8465-634ffc95679b.gif

原本应该只是qrcode/4/9/ba9c4b18-57eb-46ea-8465-634ffc95679b.gif的








