// ---------------------------Shiro认证操作者身份---------------------------
		Subject subject = SecurityUtils.getSubject();
		String principal = (String) subject.getPrincipal();
		// 执行当前新建操作的管理者的User对象
		User doingMan = null;
		// 标记当前执行者是否是admin
		boolean isAdmin = false;
		if (28 == principal.length()) {
			// openID是恒定不变的28个字符，说明本次登陆是通过openID登陆的（微信端自动登陆/login.jsp登陆）
			doingMan = this.queryByOpenId(principal);
		} else {
			// 用户名登陆（通过signin.jsp页面的表单提交的登陆）
			// 先判断是不是使用admin+admin 的方式登录的测试管理员
			if ("admin".equals(principal)) {
				isAdmin = true;
			} else {
				// 非admin用户登录
				doingMan = this.getUserByUsername(principal);
			}
		}






总计划：
1、完成MinusFirstLevel展示详情Modal的功能
2、层级对象创建的时候生成具有特定格式的二维码，初步设计结构是
"level_-1$id_c7ca3c4c-c084-41bc-babb-33c60f28fc30"
这样当用户通过微信扫描某个层级对象的二维码的时候，该字符串就会从微信服务器传递到我们自己的服务器，然后通过分析就能得知该用户扫描要加入的组织层级对象的级别，并通过id获取到该层级对象，完成一系列修改用户所在层级位置的操作。




12、基于Shiro继续精细化完成层级化管理的操作，做到各个层级只能看到自己应该看到的东西，只能操作自己被允许操作的事务，至此USER人员和组织层级化的工作基本完成。
13、实名认证页面
14、修改微信公众号菜单，取消实名认证这个菜单组，使得所有新加入用户直接就能看到正式用户菜单，但是在我们自己的web应用后台做一个Filter或Interceptor操作检测访问系统功能的用户是否完成实名认证（cardid是否为null）如果没有则跳转到实名认证JSP页面，强制要求用户实名认证，否则不能使用任何功能，这就解决了微信菜单缓存的问题。
15、重新搭建微信端对我应用程序页面的OATHUR2.0 、 API等的设置
16、重新开启websocket，实现扫描二维码登录web后台操作。




细节计划：
11、在User用户管理组件中完成用户管理-人员任命的功能，完成人员与层级对象的绑定

12、开启Shiro功能部分并进行个性化开发
（1）开发一个用用户名+密码（开发阶段一概使用123做为密码）登录页面
（2）开发一个新的myRealm用于进行身份认证（Authentication）
（3）开发其他部分的Shiro类
（4）在web.xml开启Shiro功能入口————————一个filter
（5）在spring的配置文件applicationContext.xml中队shiro功能进行必要设置
（6）根据已经批量设置完成的权限（permissionLevel:permissonType:permission这些已经存在了数据库中）对整个后台系统页面进行部署（通过Shiro的JSP自定义标签）
（7）部署工程到TOMCAT环境中进行测试，测试内容包括：
①用户身份认证（登录）是否成功，密码/用户名错误是否会跳珠到预先在spring配置中设置好的信息反馈页面，都正确是否会正常登录到系统后台	
②增加在新建层级化对象的Action过程中，首先通过Shiro获取当前操作实施者的层级对象，然后在该层级对象之下创建层级对象。
③增加在新建用户的Action中，首先通过Shiro获取当前操作者所管理的层级对象，然后在层级对象之下新建一个用户。
④增加用户管理-待分配人员 的基本分配功能（可以在这里看到自己直接父层级对象所管理的人员，且这部分人员不属于任何自己兄弟层级对象，然后可以将其中人员纳入到自己管辖内）
⑤在admin、MinusFirst、Zero、First、Second、Third、Fourth层级对象之间断进行登录切换，查看权限JSP标签是否部署正常（该某个层级管理者能见到的东西就应该能看到，其他不该他看到的东西应该看不到）


Bug修正：
3、人员任免的Modal需要根据shiro的权限层次来特性化显示。

5、人员派任界面————当前操作者层级对象，且次级为null的人员均在此目录中显示，具有如下功能：
（1）更改tag分组————只能更改包括unreal/common和当前操作者层级次一级的tag，不能越级设置tag，体现不在其位不谋其政的原则
（2）委任——————如果tag是当前操作者层级对象次一级的tag，则可以实现被操作对象与当前操作者层级对象所管理的次层级对象的关联（委任）
（3）解除委任，是第二像功能的逆向操作，且如果想修改已经被委任的人员的tag为unreal/common，则只能先接触委任后次啊能进行
（4）分派————将该人员指派给当前操作者层级对象次一级的层级对象管理，但必须要求其tag为unreal或common，不能是管理层tag，因为任何管理层都必须是“中间层”的人员
（5）下层级人员包括直属层级+所有子孙层级的人员；
	直属人员是属于自己当前层级，但不属于任何子层级的人员；
	当前层级只有权操作直属人员，包括更改tag、委任、解除委任、分派给次层级；
	当前层级无权更改非直属人员，也就是说不能跨级操作人员的tag、委任、分派等；
	这遵循了“不在其位，不谋其政”的管理原则。
	
6、整改从MinusFirstLevelAction 到 FourthLevelAction 的createLevel()方法 
需要根据Shiro得出当前操作的执行者的层级对象，然后判断该层级对象是不是自己层级的直接父层级，如果是则新建层级对象并与父层级建立层级关系，如果不是则向前端返回错误消息。



7、社区层级页面，点击“权限”设置没有反应
8、人员管理中，关于“新建人员”和“修改人员”都只应该放在直辖人员管理中
9、人员管理-修改-modal-分组select中的option只应该包括  次一级tag+common+unreal  这三个







