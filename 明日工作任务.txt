// ------------------------------系统需要初始化的内容--------------------------
（1）grouping表中的tag标签————initTag.properties  通过WeiXinAction.recall()在接受到与微信端的初次握手时在case "first":分支中通过调用WeixinService4Setting.InitPlatform() 实现
（2）projectType表中的项目类型数据————projectTypes.properties  通过方式，同上
（3）层级类型-权限类型-权限的初始化————permissionConfig/PermissionLevel_PermissionType_Permission.json 通过Admin权限登陆系统后，在权限页面下拉列表中批量创建。

（4）如果希望清空系统中的所有数据库数据，只需要放心大胆的通过HeidiSQL，依次将每个数据库表中的所有数据删除就可以了

// ---------------------------数据库操作注意事项---------------------------
（1）一对一表关系。 由于两个表的数据公用同一个主键，因此在实际通过Hibernate对持久化状态对象进行操作的时候一定要注意，在新建数据的时候，一对一的两个表新建的持久化状态对象，相互之间一定要都被引用，也就是A.B = B; B.A = A; 之后再级联地保存其中一个例如 Aservice.save(A); 或 Bservice.save(B); 就能建立关联了，否则会出现从表找不到主键的Hibernate异常。这是因为Hibernate在生成一对一关联数据的时候，从表的主键是通过主表对象的主键获取的，因此你必须向从表持久化状态对象的主表引用中引用主表对象，这样Hibernate才能通过该引用找到主表的持久化状态对象，然后得到主表的主键值。
（2）主表以List<Object> 容器来承装从表对象时，Hibernate为了能辨识出存入List容器中从表对象的先后顺序，会在所关联的从表中加入一个我通常会命名为“index4主表名”的字段用来存放从表新建的先后次序，这样当Hibernate级联地从从表中获取与主表管理的数据到List容器中的时候，就能通过这个次序在容器中排列好先后顺序。因此在实际新建从表数据的时候，应该获取到主表对象，然后从主表中获取到list容器然后调用list的add()方法将新建的从表对象放入到容器中，然后从表中的主表字段也要引用到主表对象，最后再级联地保存从表对象就能完成新建从表和确定从表次序的工作。否则，如果只是通过从表中的主表引用来引用主表，而不在主表的list容器中添加新建的从表对象，那么新建的从表对象的“index4主表名”的字段就会为null缺少排列序号。

// ---------------------------常见异常处理---------------------------
（1）如果你发现Spring的beanFactory在加载某个Bean的时候爆出找不到某某Bean的情况，那么就重启Eclipse，并且调出任务管理器将后台运行的所有Java程序关闭，然后重启Eclipse重启服务器。
（2）如果你发现某些jar缺失，这是由于Maven加载的问题，解决办法是在项目名称上单机右键，然后选择Maven→Update 从网络或本地仓库更新
（3）如果你发现一些配置文件并没有更新到Tomcat服务器上，则你需要先关闭tomcat服务器，然后到服务器根目录下的/webapp中将项目已部署的web应用程序目录删除，然后在项目名称上单击右键，然后Run as → Maven clean 清除项目中target目录中的旧文件；
然后再Run as → Maven build → 在操作意图中写上"compile" 重新编译工程中的所有配置文件、java源文件等到target，最后再次启动tomcat服务器，这样一来当重新部署工程到服务器上的时候就会将target中新编译的内容部署到服务器了。
（4）如果出现Maven的某些工具、插件没有安装成功导致异常，则需要Run as → Maven Install 重新向当前工程中安装Maven所需要插件。

// ---------------------------Shiro认证操作者身份---------------------------
		Subject subject = SecurityUtils.getSubject();
		String principal = (String) subject.getPrincipal();
		// 执行当前新建操作的管理者的User对象
		User doingMan = null;
		// 标记当前执行者是否是admin
		boolean isAdmin = false;
		if (28 == principal.length()) {
			// openID是恒定不变的28个字符，说明本次登陆是通过openID登陆的（微信端自动登陆/login.jsp登陆）
			doingMan = this.queryByOpenId(principal);
		} else {
			// 用户名登陆（通过signin.jsp页面的表单提交的登陆）
			// 先判断是不是使用admin+admin 的方式登录的测试管理员
			if ("admin".equals(principal)) {
				isAdmin = true;
			} else {
				// 非admin用户登录
				doingMan = this.getUserByUsername(principal);
			}
		}

// ---------------------------系统登陆的逻辑流程---------------------------
		
前端来访 → MyShiroFilter将所请求的URL进行分析，如果发现名为code的请求参数就放到session域中命名为wxURL，也就是判定本次来访时来自微信端的 → Shiro的Filter过滤器链条 → 如果当前所请求的路径需要authc则转交给shiroFilter这个bean中配置的loginUrl属性所标定的Action处理 → shiroAction_login.action
						如果session中存在wxURL，认定为微信端来访 → 执行认证操作 → 返回结果集索引字符串SUCCESS → 通过shiroAction.wxURL作为动态结果集访问原目标路径
					  /
→ShiroAction.login() → 											  							 扫码 → shiroAction.ws4Login();
					  \																	   /
						如果session中不存在wxURL，为桌面端来访→	跳转到/openJSP/sigin.jsp → 
																						   \
																							 传统 → shiroAction.login4Input();
		
		
		
		
		
		
		
		

总计划：
1、完成MinusFirstLevel展示详情Modal的功能
14、修改微信公众号菜单，取消实名认证这个菜单组，使得所有新加入用户直接就能看到正式用户菜单，但是在我们自己的web应用后台做一个Filter或Interceptor操作检测访问系统功能的用户是否完成实名认证（cardid是否为null）如果没有则跳转到实名认证JSP页面，强制要求用户实名认证，否则不能使用任何功能，这就解决了微信菜单缓存的问题。
16、重新开启websocket，实现扫描二维码登录web后台操作。
细节计划：












