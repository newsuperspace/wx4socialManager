// ------------------------JUnit测试顺序----------------------------
√（0）删除数据库weixin →  新建数据库weixin
√（1）TestGroupingService.testBatchCreateGrouping()  
① 根据hibernate配置文件完成数据库表的全部搭建
② 初始化grouping中的数据（必要且优先）
√（2）TestProjectType.testBatchCreateProjectType()
初始化“项目类型”数据信息，这些信息将作为创建BesureProject（默认） → DoingProject（默认） → 各个层级对象的前提（必要且优先）
√（3）TestBesureProject、 TestDoingProject
√（4）TestXXXXLevelService
√（5）User 和 Member(新建用户必须伴随创建一个默认member)
√（6）Manager
√（7）House 和  Geo
（8）Activity、article、articlephoto



// ------------------------------系统需要初始化的内容--------------------------
（1）grouping表中的tag标签————initTag.properties  通过WeiXinAction.recall()在接受到与微信端的初次握手时在case "first":分支中通过调用WeixinService4Setting.InitPlatform() 实现
（2）projectType表中的项目类型数据————projectTypes.properties  通过方式，同上
（3）层级类型-权限类型-权限的初始化————permissionConfig/PermissionLevel_PermissionType_Permission.json 通过Admin权限登陆系统后，在权限页面下拉列表中批量创建。

（4）如果希望清空系统中的所有数据库数据，只需要放心大胆的通过HeidiSQL，依次将每个数据库表中的所有数据删除就可以了，然后再通过接入微信时通WeixinService4Setting.InitPlatform()完成grouping和projectType的创建，然后通过admin登陆系统后台完成权限系统的新建，整个系统就可用了。

// ---------------------------数据库操作注意事项---------------------------
（1）一对一表关系。 由于两个表的数据公用同一个主键，因此在实际通过Hibernate对持久化状态对象进行操作的时候一定要注意，在新建数据的时候，一对一的两个表新建的持久化状态对象，相互之间一定要都被引用，也就是A.B = B; B.A = A; 之后再级联地保存其中一个例如 Aservice.save(A); 或 Bservice.save(B); 就能建立关联了，否则会出现从表找不到主键的Hibernate异常。这是因为Hibernate在生成一对一关联数据的时候，从表的主键是通过主表对象的主键获取的，因此你必须向从表持久化状态对象的主表引用中引用主表对象，这样Hibernate才能通过该引用找到主表的持久化状态对象，然后得到主表的主键值。
（2）主表以List<Object> 容器来承装从表对象时，Hibernate为了能辨识出存入List容器中从表对象的先后顺序，会在所关联的从表中加入一个我通常会命名为“index4主表名”的字段用来存放从表新建的先后次序，这样当Hibernate级联地从从表中获取与主表管理的数据到List容器中的时候，就能通过这个次序在容器中排列好先后顺序。因此在实际新建从表数据的时候，应该获取到主表对象，然后从主表中获取到list容器然后调用list的add()方法将新建的从表对象放入到容器中，然后从表中的主表字段也要引用到主表对象，最后再级联地保存从表对象就能完成新建从表和确定从表次序的工作。否则，如果只是通过从表中的主表引用来引用主表，而不在主表的list容器中添加新建的从表对象，那么新建的从表对象的“index4主表名”的字段就会为null缺少排列序号。

// ---------------------------常见异常处理---------------------------
（1）如果你发现Spring的beanFactory在加载某个Bean的时候爆出找不到某某Bean的情况，那么就重启Eclipse，并且调出任务管理器将后台运行的所有Java程序关闭，然后重启Eclipse重启服务器。
（2）如果你发现某些jar缺失，这是由于Maven加载的问题，解决办法是在项目名称上单机右键，然后选择Maven→Update 从网络或本地仓库更新
（3）如果你发现一些配置文件并没有更新到Tomcat服务器上，则你需要先关闭tomcat服务器，然后到服务器根目录下的/webapp中将项目已部署的web应用程序目录删除，然后在项目名称上单击右键，然后Run as → Maven clean 清除项目中target目录中的旧文件；
然后再Run as → Maven build → 在操作意图中写上"compile" 重新编译工程中的所有配置文件、java源文件等到target，最后再次启动tomcat服务器，这样一来当重新部署工程到服务器上的时候就会将target中新编译的内容部署到服务器了。
（4）如果出现Maven的某些工具、插件没有安装成功导致异常，则需要Run as → Maven Install 重新向当前工程中安装Maven所需要插件。

（5）2018年8月5日，今天把已经完成的双Realm（myRealm用来验证扫码登陆/myRealm4Input用来验证用户名密码登陆）的系统接入到微信中后，新建菜单也已经生效。这个时候当我点击微信端登陆系统后台的时候出现了一个奇怪的问题
org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: cc.natapp4.ddaig.domain.Manager.zls, could not initialize proxy - no Session
这是一个Hibernate中非常经典的no session异常，我之前很奇怪不仅仅是因为已经在系统中部署了Spring提供的同意管理session的OpenSessionInView过滤器，还因为在测试版本中这个微信端直接登陆系统后台的功能是正常的。该异常发生的位置是在调用myRealm.doGetAuthorizationInfo()获取权限列表的时候出现的，我原本以为Shiro会一次性同时调用doGetAuthenticationInfo()和doGetAuthorizationInfo()两个方法，但经过我在网上查阅资料后才知道，登陆时会调用doGetAuthenticationInfo()完成认证，但不会继续调用doGetAuthorizationInfo()，而是等到JSP的shiro标签/applicationContext的shiro过滤器链条中规定某个url需要某种权限/shiro在类的方法上的权限注解并且该方法被调用，这三种情况发生的时候才会执行doGetAuthorizationInfo()这其实也是一种懒加载策略。
知道这一点后我明白了，no session异常发生的位置不会是doGetAuthentication()认证的阶段，而是在之后比如说认证完成后的请求重定向或请求转发的访问阶段出发了doGetAuthorizationInfo()进行授权的时候发生的，于是我查看了控制台打印的信息，发现在shiroAction_login.action自动登陆成功后会通过action中的名为wxUrl的属性进行动态结果集的请求重定向，二改wxUrl的打印地址是
“最终存入Session的完整wxURL：http://ddaig.nat200.top/weixin/?code=071LgoS22lA90Y0wF7Q22qudS22LgoSY&state=”  我们看到这个连接不是*.action格式，而我在web.xml定义OpenSessionInView过滤器的时候规定的过来规则是"*.action"，至此问题已经很明了了，我们wxURL所请求转发的路径没有出发openSessionInView，自然在doGetAuthorizationInfo中通过userService.queryEntityByOpenID() 得到user后session就关闭了，由于user.manager不是拦截在因此还是可以得到manager的（不需要通过session从数据库中请求），但是manager中的所有容器缺失在HBM中设定为了懒加载，当我们获取容器的时候由于session已经关闭，自然就会报出 no session的异常。
而测试版本之所以能正常，是因为测试版本的wxURL所请求的是directPageAction，而该action在新版本的系统中已经弃用了。
因此该问题的解决办法就是设置OpenSessionInView拦截器的规则为"/*"



// ---------------------------Shiro认证操作者身份---------------------------
		Subject subject = SecurityUtils.getSubject();
		String principal = (String) subject.getPrincipal();
		// 执行当前新建操作的管理者的User对象
		User doingMan = null;
		// 标记当前执行者是否是admin
		boolean isAdmin = false;
		if (28 == principal.length()) {
			// openID是恒定不变的28个字符，说明本次登陆是通过openID登陆的（微信端自动登陆/login.jsp登陆）
			doingMan = this.queryByOpenId(principal);
		} else {
			// 用户名登陆（通过signin.jsp页面的表单提交的登陆）
			// 先判断是不是使用admin+admin 的方式登录的测试管理员
			if ("admin".equals(principal)) {
				isAdmin = true;
			} else {
				// 非admin用户登录
				doingMan = this.getUserByUsername(principal);
			}
		}

// -------------------------定位当前操作者层级对象下的直属成员对应的member-----------------------------
String  levelTag  = (String) ServletActionContext.getRequest().getSession().getAttribute("tag");
String  lid  = (String) ServletActionContext.getRequest().getSession().getAttribute("lid");
for(Member m : members){
	switch(levelTag){
	case "minus_first":
		if(null!=m.getMinusFirstLevel() && m.getMinusFirstLevel().getMflid().equals(lid) && null==m.getZeroLevel()){
			member = m;
		}
		break;
	case "zero":
		if(null!=m.getZeroLevel() && m.getZeroLevel().getZid().equals(lid) && null==m.getFirstLevel()){
			member = m;
		}
		break;
	case "first":
		if(null!=m.getFirstLevel()&&m.getFirstLevel().getFlid().equals(lid) && null==m.getSecondLevel()){
			member = m;
		}
		break;
	case "second":
		if(null!=m.getSecondLevel()&&m.getSecondLevel().getScid().equals(lid) && null==m.getThirdLevel()){
			member = m;
		}
		break;
	case "third":
		if(null!=m.getThirdLevel() && m.getThirdLevel().getThid().equals(lid) && null==m.getFourthLevel()){
			member = m;
		}
		break;
	case "fourth":
		if(null!=m.getFourthLevel()&&m.getFourthLevel().getFoid().equals(lid)){
			member = m;
		}
		break;
	}
}		
		
		

// ---------------------------系统登陆的逻辑流程---------------------------
		
前端来访 → MyShiroFilter将所请求的URL进行分析，如果发现名为code的请求参数就放到session域中命名为wxURL，也就是判定本次来访时来自微信端的 → Shiro的Filter过滤器链条 → 如果当前所请求的路径需要authc则转交给shiroFilter这个bean中配置的loginUrl属性所标定的Action处理 → shiroAction_login.action
						如果session中存在wxURL，认定为微信端来访 → 执行认证操作 → 返回结果集索引字符串SUCCESS → 通过shiroAction.wxURL作为动态结果集访问原目标路径
					  /
→ShiroAction.login() → 											  							 扫码 → shiroAction.ws4Login();
					  \																	   /
						如果session中不存在wxURL，为桌面端来访→	跳转到/openJSP/sigin.jsp → 
																						   \
																							 传统 → shiroAction.login4Input();
				
		
		

总计划：
4、在创建活动Activity是可选择是自动完成签退还是手动签退的选项
5、【项目化管理方案】为DoingProject和BesureProject增加新的字段（minusFirstProject、zeroProjectLevel、firstProjectLevel、secondProjectLevel、thirdProjectLevel、fourthProjectLevel），将“组织层级化”管理理念引入到“项目管理”中。新字段与已有的层级化字段的区别是，
/*
 * ★★★
 * 注意，不论是doingProject还是besureProject都与层级对象类似，
 * 为了能够快速便利出某个层级对象之下所有子层级对象所执行的项目
 * 也为了能够逐本溯源，找到项目的最初（通常是minusFirst或zeroLevel）
 * 下发的层级对象，因此其中的MInusFirstLevel、ZeroLevel、FirstLevel、
 * SecondLevel、ThirdLevel、FourthLevel都要从项目所属层级（当前就是ZeroLevel）
 * 一直向上追溯到最顶层级（MinusFirstLevel）这样才能方便表现出项目的层级化关系
 * 至少目前来说随层级创建的“默认项目”是这样的，
 *
 * 
 */
简单言之就是已有层级字段是用来指示该项目当前执行者是谁，以及属于哪个更高层级之下；
而新建字段是用来独立表示一个项目的层级关系，因为之后推行项目化运作方案，从minus（联合会或街道）可以向各个社区摊派积分，就是要通过带积分的大项目包的形式分派给各个社区，然后各个社区再次拆包成小项目分派各自的子层级，然后再拆包。而且社区有自己的经费也可以创建自己的带积分项目向下进行分派。
所以所有拆出来的子项目都应该能追根溯源到其所属于的父项目包，然后每个项目包又能通过旧字段定位到当前执行项目的层级对象。



细节计划：
1、街道层级应该增加房屋管理功能，实际上从整个层级结构来看，房屋管理功能；

2、由于同一个USER在整个层级结构很可能存在多个member，因此某个层级管理者在获取非直辖人员时很可能会获取到同一个user的多个member从而在列表中重复出现同一个人；

3、默认项目 →  活动 → 参与者数字 点击后应该打开一个列表页面显示报名者的信息

4、用户通过扫码加入某一个层级后 → 申请表单页面 → 申请中...
												→ 审核事项 → 申请加入 → 列表





// ==============================================WeUI设计"个人中心"=============================================
一、重要的参考资料：
（1）weui.css   	https://github.com/Tencent/weui/wiki
（2）weui.js		https://github.com/Tencent/weui.js/blob/master/docs/README.md
（3）WeUI的Demo		https://weui.io/
（4）WeUI.js的Demo	https://weui.io/weui.js/

二、WeUI组件的使用参考：
（1）ActionSheet
用来提供从低端弹起的功能菜单
（2）Cell和badge结合的消息列表
https://weui.io/#badge
（3）Cell，列表视图，用于将信息以列表的结构显示在页面上
https://github.com/Tencent/weui/wiki/Cell

三、当前任务需求：





// =================================数据库构建思路=================================

（1）用户申请加入组织层级以及组织管理者审核申请的数据库模型，一对一对多的三个表

userApply4JoinLevel   ← 一对一 →  approve4UserJoinLevel  ← 一对多 → reply4UserJoinLevelApprove

userApply4JoinLevel:
	ua4jlid （UUID主键）
	user  （外键，与用户进行一对多关联，由此可定位用户的基本信息）
	
	timeStr （形如： yyyy-MM-dd HH:mm:ss 的日期字符串，记录提交申请的日期）
	timeStamp （格里高利历偏移量毫秒值）
	
	theReason （前端表单字段：申请加入的原因）
	theExpertise （前端表单字段：你的专长）
	theDesire （前端表单字段：你的期许）
	
	status  （新建数据默认为0，代表“受理中”层级管理者“否决”申请，设置为1； 层级管理者“通过”申请，设置为2）
	beread （默认为NULL,只有当status为非0是，该标记位才会被关注，并且false表示组织层级管理者已经完成处理但是提交申请的用户还没看到，直到首次加载本数据的时候才会永久变更为true）
	
	
approve4UserJoinLevel:
	a4ujlid （foreign主键，与ua4jlid共用主键）
	tag （形如：minus_first/zero/first/second/third/fourth  这样的组织层级字段，用来联合lid一起定位用户提交申请的目标组织）
	lid （组织的主键id，与tag合作可以从数据库中定位用户所要申请加入的具体组织）
	beread （随同userApply4JoinLevel新建数据后，默认为false，用来表示新请求是否被层级管理者阅读过了，首次加载数据的时候会优秀修正为true）
	
	
reply4UserJoinLevelApprove：
	r4ujlaid （UUID主键）
	message （回复的内容）
	timeStr （形如： yyyy-MM-dd HH:mm:ss 的日期字符串）
	timeStamp （格里高利历偏移量毫秒值）
	beread （新建后默认就是false，只有当用户加载本条数据的时候才会永久修正为true，表示本数据是否已经被读取过）


// =========================================开发经验===========================================	
1、如果在服务器启动后，发现action的配置文件struts-XXX.xml中需要修改，则可以直接修改保存即可生效，无需重新启动服务器。
2、我们知道JSP的本质实际上就是servlet类，但是当服务器启动后，我们在JSP上的修改保存后也能立刻生效，无需重启服务器。
3、JavaScript脚本也是可以直接修改，然后直接生效，无需重启服务器。
4、目前经验来看，服务器已debugging模式开启后，对源代码（主要是java代码）的修改也是可以直接生效的，无需重启服务器。而如果没生效就需要重新deploying重启服务器了。


	
	
	
	

// =========================================明日工作内容===========================================
明天的工作就是：

（1）非直辖人员界面，可以设置下拉列表形如：

《minus_first层级下拉》  →选中后激活下一层级的下拉列表→  《zero层级下拉》  →选中后激活下一层级的下拉列表→ 《first层级下拉》。。。。。。。
每选中一级，就自动在列表中筛选出选中层级下属的成员

（2）在活动页面中，有关报名人数的数字上，添加报名人员名单列表页面  √

（3）微信端→ 个人中心→ 已加入的组织层级 中。新字段与已有的层级化字段的区别是，preview预览中    √
应该添加从
		minus_first
		zero
		first
		second
		third
		fourth
	的内容，用于标记出该组织在层级中的位置，一目了然。

（4） 用户中心页 → 用户点击自己的用户名时，会弹出一个dialog，显示如下信息，并提供修改入口	
二维码
我的地址
我的ID
我的性别













