// ------------------------------系统需要初始化的内容--------------------------
（1）grouping表中的tag标签————initTag.properties  通过WeiXinAction.recall()在接受到与微信端的初次握手时在case "first":分支中通过调用WeixinService4Setting.InitPlatform() 实现
（2）projectType表中的项目类型数据————projectTypes.properties  通过方式，同上
（3）层级类型-权限类型-权限的初始化————permissionConfig/PermissionLevel_PermissionType_Permission.json 通过Admin权限登陆系统后，在权限页面下拉列表中批量创建。

（4）如果希望清空系统中的所有数据库数据，只需要放心大胆的通过HeidiSQL，依次将每个数据库表中的所有数据删除就可以了

// ---------------------------数据库操作注意事项---------------------------
（1）一对一表关系。 由于两个表的数据公用同一个主键，因此在实际通过Hibernate对持久化状态对象进行操作的时候一定要注意，在新建数据的时候，一对一的两个表新建的持久化状态对象，相互之间一定要都被引用，也就是A.B = B; B.A = A; 之后再级联地保存其中一个例如 Aservice.save(A); 或 Bservice.save(B); 就能建立关联了，否则会出现从表找不到主键的Hibernate异常。这是因为Hibernate在生成一对一关联数据的时候，从表的主键是通过主表对象的主键获取的，因此你必须向从表持久化状态对象的主表引用中引用主表对象，这样Hibernate才能通过该引用找到主表的持久化状态对象，然后得到主表的主键值。
（2）主表以List<Object> 容器来承装从表对象时，Hibernate为了能辨识出存入List容器中从表对象的先后顺序，会在所关联的从表中加入一个我通常会命名为“index4主表名”的字段用来存放从表新建的先后次序，这样当Hibernate级联地从从表中获取与主表管理的数据到List容器中的时候，就能通过这个次序在容器中排列好先后顺序。因此在实际新建从表数据的时候，应该获取到主表对象，然后从主表中获取到list容器然后调用list的add()方法将新建的从表对象放入到容器中，然后从表中的主表字段也要引用到主表对象，最后再级联地保存从表对象就能完成新建从表和确定从表次序的工作。否则，如果只是通过从表中的主表引用来引用主表，而不在主表的list容器中添加新建的从表对象，那么新建的从表对象的“index4主表名”的字段就会为null缺少排列序号。

// ---------------------------常见异常处理---------------------------
（1）如果你发现Spring的beanFactory在加载某个Bean的时候爆出找不到某某Bean的情况，那么就重启Eclipse，并且调出任务管理器将后台运行的所有Java程序关闭，然后重启Eclipse重启服务器。
（2）如果你发现某些jar缺失，这是由于Maven加载的问题，解决办法是在项目名称上单机右键，然后选择Maven→Update 从网络或本地仓库更新
（3）如果你发现一些配置文件并没有更新到Tomcat服务器上，则你需要先关闭tomcat服务器，然后到服务器根目录下的/webapp中将项目已部署的web应用程序目录删除，然后在项目名称上单击右键，然后Run as → Maven clean 清除项目中target目录中的旧文件；
然后再Run as → Maven build → 在操作意图中写上"compile" 重新编译工程中的所有配置文件、java源文件等到target，最后再次启动tomcat服务器，这样一来当重新部署工程到服务器上的时候就会将target中新编译的内容部署到服务器了。
（4）如果出现Maven的某些工具、插件没有安装成功导致异常，则需要Run as → Maven Install 重新向当前工程中安装Maven所需要插件。

（5）2018年8月5日，今天把已经完成的双Realm（myRealm用来验证扫码登陆/myRealm4Input用来验证用户名密码登陆）的系统接入到微信中后，新建菜单也已经生效。这个时候当我点击微信端登陆系统后台的时候出现了一个奇怪的问题
org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: cc.natapp4.ddaig.domain.Manager.zls, could not initialize proxy - no Session
这是一个Hibernate中非常经典的no session异常，我之前很奇怪不仅仅是因为已经在系统中部署了Spring提供的同意管理session的OpenSessionInView过滤器，还因为在测试版本中这个微信端直接登陆系统后台的功能是正常的。该异常发生的位置是在调用myRealm.doGetAuthorizationInfo()获取权限列表的时候出现的，我原本以为Shiro会一次性同时调用doGetAuthenticationInfo()和doGetAuthorizationInfo()两个方法，但经过我在网上查阅资料后才知道，登陆时会调用doGetAuthenticationInfo()完成认证，但不会继续调用doGetAuthorizationInfo()，而是等到JSP的shiro标签/applicationContext的shiro过滤器链条中规定某个url需要某种权限/shiro在类的方法上的权限注解并且该方法被调用，这三种情况发生的时候才会执行doGetAuthorizationInfo()这其实也是一种懒加载策略。
知道这一点后我明白了，no session异常发生的位置不会是doGetAuthentication()认证的阶段，而是在之后比如说认证完成后的请求重定向或请求转发的访问阶段出发了doGetAuthorizationInfo()进行授权的时候发生的，于是我查看了控制台打印的信息，发现在shiroAction_login.action自动登陆成功后会通过action中的名为wxUrl的属性进行动态结果集的请求重定向，二改wxUrl的打印地址是
“最终存入Session的完整wxURL：http://ddaig.nat200.top/weixin/?code=071LgoS22lA90Y0wF7Q22qudS22LgoSY&state=”  我们看到这个连接不是*.action格式，而我在web.xml定义OpenSessionInView过滤器的时候规定的过来规则是"*.action"，至此问题已经很明了了，我们wxURL所请求转发的路径没有出发openSessionInView，自然在doGetAuthorizationInfo中通过userService.queryEntityByOpenID() 得到user后session就关闭了，由于user.manager不是拦截在因此还是可以得到manager的（不需要通过session从数据库中请求），但是manager中的所有容器缺失在HBM中设定为了懒加载，当我们获取容器的时候由于session已经关闭，自然就会报出 no session的异常。
而测试版本之所以能正常，是因为测试版本的wxURL所请求的是directPageAction，而该action在新版本的系统中已经弃用了。
因此该问题的解决办法就是设置OpenSessionInView拦截器的规则为"/*"



// ---------------------------Shiro认证操作者身份---------------------------
		Subject subject = SecurityUtils.getSubject();
		String principal = (String) subject.getPrincipal();
		// 执行当前新建操作的管理者的User对象
		User doingMan = null;
		// 标记当前执行者是否是admin
		boolean isAdmin = false;
		if (28 == principal.length()) {
			// openID是恒定不变的28个字符，说明本次登陆是通过openID登陆的（微信端自动登陆/login.jsp登陆）
			doingMan = this.queryByOpenId(principal);
		} else {
			// 用户名登陆（通过signin.jsp页面的表单提交的登陆）
			// 先判断是不是使用admin+admin 的方式登录的测试管理员
			if ("admin".equals(principal)) {
				isAdmin = true;
			} else {
				// 非admin用户登录
				doingMan = this.getUserByUsername(principal);
			}
		}

// ---------------------------系统登陆的逻辑流程---------------------------
		
前端来访 → MyShiroFilter将所请求的URL进行分析，如果发现名为code的请求参数就放到session域中命名为wxURL，也就是判定本次来访时来自微信端的 → Shiro的Filter过滤器链条 → 如果当前所请求的路径需要authc则转交给shiroFilter这个bean中配置的loginUrl属性所标定的Action处理 → shiroAction_login.action
						如果session中存在wxURL，认定为微信端来访 → 执行认证操作 → 返回结果集索引字符串SUCCESS → 通过shiroAction.wxURL作为动态结果集访问原目标路径
					  /
→ShiroAction.login() → 											  							 扫码 → shiroAction.ws4Login();
					  \																	   /
						如果session中不存在wxURL，为桌面端来访→	跳转到/openJSP/sigin.jsp → 
																						   \
																							 传统 → shiroAction.login4Input();
				
		
		

总计划：
1、完成MinusFirstLevel展示详情Modal的功能


细节计划：

（2）在permissionLevel_permissionType_permission.json文件中 新加入普通用户来访者的权限，这种人也可以通过微信菜单的"管理系统"按钮访问后台系统，
但是他们只能看到"活动信息"这一条大目录

或者
单独开发一个活动信息详情页，按照原定计划加入 
①可参加的活动（用来报名）
②已参加的活动（取消报名）
③活动历史
（3）活动报名功能
			将被报名的活动 从 可参加活动 → 已参加活动
	 取消报名功能
			将被取消的活动 从 已参加活动 → 可参加活动
			
（3）恢复活动扫码签到功能（与微信交互）
（4）扫码签退、积分累计、服务时长累计自动完成（与微信交互）



// ==============================================WeUI设计"个人中心"=============================================
一、重要的参考资料：
（1）weui.css   	https://github.com/Tencent/weui/wiki
（2）weui.js		https://github.com/Tencent/weui.js/blob/master/docs/README.md
（3）WeUI的Demo		https://weui.io/
（4）WeUI.js的Demo	https://weui.io/weui.js/

二、WeUI组件的使用参考：
（1）ActionSheet
用来提供从低端弹起的功能菜单
（2）Cell和badge结合的消息列表
https://weui.io/#badge
（3）Cell，列表视图，用于将信息以列表的结构显示在页面上
https://github.com/Tencent/weui/wiki/Cell

三、当前任务需求：
1、实名认证页	√
（1）成功信息页 Msg Page	√
（2）失败信息页	Msg Page	√
2、用户中心页 √
（1）个人信息页	bootstrap
二维码
我的地址
我的ID
我的性别
（2）可参加活动的列表页面 	preView	√
（3）已参加活动的列表页面	preView	√
（4）活动历史列表页面		preView	√





// =================================线下工作=================================

（8）创享计划项目设计材料总结























